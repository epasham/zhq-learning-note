===================  第五节  运行时数据区
-Xss 默认值1m  最小108K

java垃圾回收策略：主要是靠记忆，多看多记

本地方法栈：存放本地方法的位置 C或C++写的，本地方法库，为了支撑native方法的调用和执行
虚拟机栈：分配基本类型和自定义对象的引用，局部变量表等

String str1 = "hello";
String str2 = new String("hello");
System.out.println(str1 == str2);
System.out.println(str1.equals(str2));
答案：false 和 true 因为str1 和str2的地址是不相等的，str1直接指向常量区的字符串，而str2是指向堆区的对象地址，所以false

栈：里面的栈帧是按照先进后出的原则
运行时数据区：方法区、堆、虚拟机栈、本地方法栈、程序计数器

=========================  垃圾回收策略
需要回收的区域： 堆和方法区，因为栈是线程私有的，不需要回收
jvm为每个新创建的线程都分配一个堆栈。堆栈以帧为单位保存线程的状态。jvm对堆栈只进行两种操作：以帧为单位的压栈和出栈操作。

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。
栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。
第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
什么情况下回收？
对象不再引用的时候
强引用：person = new object()
局部变量，当用完了之后，要复制为null

-XX:+PrintGC 参看GC回收情况
-XX:+PrintGCDetails 参看GC回收详情
参数输入格式：
[名称：GC前内存占用->GC后内存占用(该区域内存总大小)，GC占用时间]
-XX:+UseSerialGC

标记——清除算法：效率不高，产生大量不连续的空间碎片
复制算法：内存分两块，但是利用率低
标记整理算法：标记清除的基础上再整理
JVM 用可达性分析，分析的时候进行标记
商业算法：分代，根据对象存活周期
示意图见PPT
没听明白分代收集，eden from to old

新生代收集：minorGC ==> 小内存
           majorGC
           fullGC ==> 要尽量少出现
