## chapter2  线程安全性
```
一个对象，如果没有状态，只有方法，则是线程安全的。
竞态条件：先检查后执行 场景下容易发生
（1）延迟初始化
单例模式的例子
（2）读取——修改——写入
count++

获得对象内置锁的唯一途径是进入由这个锁保护的同步代码块或方法
内置锁是可重入的

在没有同步的情况下，编译器、处理器可能对操作的执行顺序进行重排序，得到一些意想不到的调整。
对于double和long数据，其读写操作不是原子的，如果没有volatile修饰，也是不安全的

加锁的含义不仅仅局限于互斥行为，还包括了内存可见性
volatile变量的典型用法 ： 检查某个标记的状态，判断是否退出循环，但是不能确保++操作的原子性，
总之，仅仅保证可见性，不能保证原子性。
而加锁机制既可以保证可见性，又可以保证原子性。
volatile boolean asleep;
while(!asleep)
  countSomeSheep();

发布对象：
（1）将该对象的引用保存在一个公有的静态变量中。

除非某个域是可变的，否则声明为final是个好习惯
```
## chapter4  对象的组合
CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，
而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器
的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前
容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如
我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。
这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前
关键字在不在黑名单当中，如果在，则提示不能搜索

　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。
　　内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。
　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。
　　数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。



堵塞队列适应于  生产者——消费者模式
双端队列适用于  工作密取，适应于既是消费者，又是生产者的问题
