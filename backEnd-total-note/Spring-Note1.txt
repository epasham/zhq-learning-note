======================  Spring框架  ==============================
轻量级、一站式、开发框架
核心技术：控制反转Inversion of Control(IoC，控制反转)
Aspect-Oriented Programming(AOP，面向切面编程)

1 IoC技术
控制：对象的依赖关系Dependency Injection(DI,依赖注入)
IoC容器实现依赖注入，对象的创建与组合


2 AOP 面向切面编程
aspect-oriented Programming
日志
业务逻辑与非业务逻辑分离
IoC容器：对象创建、装配；声明周期管理、上下文环境等
AOP：
数据访问：JDBC支持、事务管理、ORM整合
Web：Servlet Based MVC  Web工具支持
Spring Framework：开发工具、框架整合

3 Web应用实例
===========  实例已完成  ============

2.1 IoC容器概述
core container
IoC容器 = ApplicationContext

Bean的作用域（有效范围）
创建、销毁时间
常用的作用域：
singleton（单例模式，默认） scope = "singleton"
prototype（每次引用创建新实例）scope = "prototype"
request scope
session scope
application scope
Bean生命周期回调
创建：申请资源 afterPropertiesSet()
销毁：释放资源

2.2 依赖注入
基于构造函数的注入：强依赖
基于Setter方法的注入：可选依赖（可配置的）
基本类型（int, String）
集合类
Bean
配置文件

注入集合
java  List
===================  通过构造函数进行依赖注入的例子已经完成  ===================
依赖注入2：主要介绍了构造函数注入和set注入两种方式

2.4 自动装配与annotation
===========================================================
自动装配与annotation(！！！！！需要再看一遍理解一下！！！！！)
============================================================
autowiring
byName、byType、constructor


3.1 AOP概述

优点：代码重用、解耦业务逻辑与非业务逻辑
Aspect :日志、安全等功能
join point:函数执行或者属性访问
advice：在某个函数执行点上要执行的切面功能
Pointcut：匹配横切目标函数的表达式

advice： before 、 after returning、after throwing、after finally around
spring AOP：非完整的AOP实现
XML schema-based AOP
@AspectJ annotation-based AOP

AOP使用
定义Aspect：
Pointcut表达式: designator(modifiers? return-type )

3.3 AOP使用演示
===============================================
AspectJ 为例的演示程序 重新复习一下
===============================================

4.1 Spring JDBC- 成片（上）
数据库访问  JDBC
事务管理
ORM整合

DAO : data access object  数据访问相关接口
接口与实现相分离的方法
ORM （object relation mapping）  对象关系映射
数据访问步骤：
连接参数 -> 打开连接 -> 声明SQL语句及参数 -> 执行SQL，循环访问结果 -> 执行业务 -> 处理异常 -> 关闭连接
DataSource 声明连接参数(java EE 提供的)
驱动类名、连接地址、用户名、密码
getConnection
每一次连接： DriverManagerDatasource
连接池：BasicDataSource
=========================================================
jdbcTemplate(相关的概念以及用法很多，在实践之后需要再看一遍)
=========================================================




======================   Spring 实践笔记  ===================================
===================================
spring-web ： 第一个 spring 练手项目
===================================
根据业务对象和配置，由容器产生一个可用的对象
IoC容器： ApplicatioContext
定义一个类 -> 配置bean -> 获取bean -> 应用bean
scope = "prototype"时，可创建多个实例

<bean id = "screwDriver" class = "com.cmb.course.ScrewDriver" init-method = "init" destroy-method = "destroy"></bean>
通过init-method 和 destroy-method 设定初始化以及销毁的程序代码

=====================   疑问   ===============================
依赖注入：
StraightHeader header = context.getBean("straightHeader", StraightHeader.class);
Header header = context.getBean("straightHeader", StraightHeader.class);
这两句话为什么是一样的功能？
==============================================================
集合传参  Map

一个bean依赖于另一个bean   配置方法
通过构造函数的方法来注入
<bean id = "screwDriver" class = "com.cmb.course.ScrewDriver">
  <constructor-arg>
    <ref bean = "straight"/>
  </constructor-arg>
</bean>

自动装配autowire
配置：	<bean id = "screwDriver" class = "com.cmb.course.ScrewDriver" autowire = "byName"></bean>
但是在类中需要加入set+BeanId的函数
@Component：定义bean
@Value：properties注入
@Autowired & @Resource: 自动装配依赖
@PostConstuct  @PreDestroy 声明周期回调
+ 配置

定义一个bean的名字  叫做  @Component("header")
在进行初始化的时候可以  setHeader(Header header)

JointPoint 获取函数的上下文信息
ProcessingJointPoint
returning获取返回值

事务注解的使用
@Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。
如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常





