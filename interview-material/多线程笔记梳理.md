

#### JMM 的三大特性
* 可见性
* 原子性
* 顺序性

#### 对 volatile的理解
volatile 是一种轻量级的同步机制。

* 保证数据可见性
* 不保证原子性
* 禁止指令重排序
* 如何保证原子性
    - 加锁：使用 synchronized 加锁
    - 使用 AtomicInteger

#### CAS
* CAS的缺点
    - 如果CAS失败，会一直尝试。如果CAS长时间不成功，会给CPU带来很大的开销。
    - CAS 只能用来保证单个共享变量的原子操作，对于多个共享变量操作，CAS无法保证，需要使用锁。
    - 存在 ABA 问题。
    
#### Thread
* wait和sleep的区别
    - (1)wait是Object的方法，而sleep是Thread的方法
    - (2)wait会释放monitor，并将线程加入wait-set中，但是sleep不会释放monitor
    - (3)使用wait必须要首先获取monitor，但是sleep不需要
    - (4)调用sleep不需要被唤醒，但是wait调用者需要被唤醒



    
#### 创建线程的三种方法及其区别
* 1.1 继承Thread类
* 1.2 实现Runnable接口(推荐)
* 1.3 实现Callable接口
* Java中，类仅支持单继承，如果一个类继承了Thread类，就无法再继承其它类，因此，如果一个类既要继承其它的类，又必须创建为一个线程，就可以使用实现Runable接口的方式。
* 使用实现Runable接口的方式创建的线程可以处理同一资源，实现资源的共享。
* 使用实现Callable接口的方式创建的线程，可以获取到线程执行的返回值、是否执行完成等信息。

#### Synchronized 和 Lock 的区别

* 原始构成
    - Synchronized 是关键字，属于JVM层面，底层是通过 monitorenter 和 monitorexit 完成，依赖于 monitor 对象来完成。由于 wait
    /notify 方法也依赖于 monitor 对象，因此只有在同步块或方法中才能调用这些方法。
    - Lock 是 java.util.concurrent.locks.lock 包下的，是 api层面的锁。
* 使用方法
    - Synchronized 不需要用户手动释放锁，代码完成之后系统自动让线程释放锁
    - ReentrantLock 需要用户手动释放锁，没有手动释放可能导致死锁。
* 等待是否可以中断
    - Synchronized 不可中断，除非抛出异常或者正常运行完成
    - ReentrantLock 可以中断。一种是通过 tryLock(long timeout, TimeUnit unit)，另一种是lockInterruptibly()放代码块中，调用interrupt()方法进行中断。
* 加锁是否公平
    - synchronized 是非公平锁
    - ReentrantLock 默认非公平锁，可以在构造方法传入 boolean 值，true 代表公平锁，false 代表非公平锁。

* 锁绑定多个 Condition
    - Synchronized 只有一个阻塞队列，只能随机唤醒一个线程或者唤醒全部线程。
    - ReentrantLock 用来实现分组唤醒，可以精确唤醒。

#### 线程池
* ThreadPoolExecutor
```java
public ThreadPoolExecutor(
    int corePoolSize,//线程池常驻核心线程数
    int maximumPoolSize,//线程池能容纳同时执行最大线程数
    long keepAliveTime,//多余的空闲线程的存活时间，当前线程池线程数量超过core，空闲时间达到keepAliveTime，多余空闲线程会被销毁直到只剩下core个
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,//被提交尚未被执行的任务队列
    ThreadFactory threadFactory,//创建线程的线程工厂
    RejectedExecutionHandler handler//拒绝策略
    ) 
{...}

```

* 1 创建线程池，等待提交过来的任务请求。
* 2 添加请求任务
    - 如果运行线程数小于 corePoolSize，创建线程运行该任务
    - 如果运行线程数大于等于 corePoolSize，将任务放入队列
    - 队列满，且运行线程数量小于 maximumPoolSize，创建非核心线程运行任务
    - 队列满，且运行线程数量大于等于 maximumPoolSize，线程池会启动饱和拒绝策略执行。
* 3 线程完成任务，会从队列中取下一个任务来执行
* 4 一个线程无事可做超过 keepAliveTime 时：
    - 如果当前运行线程数大于 corePoolSize，该线程被停掉
    - 线程池的所有任务完成后最终会收缩到 corePoolSize 的大小

在 JDK 中有四种内置的拒绝策略，均实现了 RejectedExecutionHandler 接口。

    AbortPolicy: 直接抛出 RejectedExecutionException 异常，是默认的拒绝策略。
    DiscardPolicy: 直接丢弃任务，不予处理也不抛出异常。如果允许任务丢失，是最好的处理策略。
    DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后把当前任务加入队列尝试再次提交。
    CallerRunsPolicy: 调用者运行。该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者。


工作中使用什么样的线程池

    在阿里巴巴Java开发手册中有如下规定：
    线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。
    说明：使用线程池的好处是减少在创建和销毁线程上消耗的时间和系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程导致消耗完内存或者过度切换。
    线程池不允许使用 Executors 去创建，也就是不能使用上述的三种线程池，而是要通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源韩进的风险。
    FixedThreadPool 和 SingleThreadPool 都采用了 LinkedBlockingQueue，其允许的队列长度为 Integer.MAX_VALUE，可能堆积大量的请求，导致OOM。
    CachedThreadPool 和 ScheduledThreadPool 允许创建的线程数量为 Integer.MAX_VALUE，可能创建大量的线程，导致OOM。

* 三种常用线程池
    - Executors.newFixedThreadPool(int)
    - Executors.newSingleThreadExecutor()
    - Executors.newCachedThreadPool()
    
    
* 如何在两个线程之间共享数据
通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的


#### 四种单例模式
```java

/**
 * 立即加载/"饿汉模式"
 */
public class SingletonPattern1 {

    /**
     * 饿汉式是线程安全的，因为虚拟机保证只会装载一次，使用的时候是已经加载初始化好的instance
     */
    private static final SingletonPattern1 INSTANCE = new SingletonPattern1();

    private SingletonPattern1() {
    }

    public static SingletonPattern1 getInstance() {
        return INSTANCE;
    }
}

//使用synchronized的线程安全的懒汉式
public class SingletonPattern2 {
    private static SingletonPattern2 instance;

    private SingletonPattern2() {
        //do sth about init
    }
    //缺点：实际上只有一个线程是写的操作（获得monitor之后new一个instance），后面的线程因为因为已经创建了instance，就是相当于读的操作，但是read的操作还是加锁同步了（串行化了），效率较低
    public synchronized static SingletonPattern2 getInstance() {
        if(null == instance) {
            instance = new SingletonPattern2();
        }
        return SingletonPattern2.instance;
    }
}

//double check + volatile的方式
public class SingletonPattern3 {

    //volatile禁止指令重排序(happens-before中有一条volatile变量规则：对一个volatile变量的写的操作先行发生与对这个变量的读操作)
    private volatile static SingletonPattern3 instance;

    //SingletonPattern3其他的一些引用类型的属性PropertyXXX  propertyxxx;

    private SingletonPattern3() {
        //do sth about init
    }

    public static SingletonPattern3 getInstance() {
        if (null == instance) {
            synchronized (SingletonPattern3.class) {
                if(null == instance) {
                    //instance = new SingletonPattern3();这句，这里看起来是一句话，但实际上它并不是一个原
                    //子操作，在被编译后在JVM执行的对应汇编代码做了大致3件事情：
                    //(1)分配内存
                    //(2)调用构造器
                    //(3)将instance对象指向分配的内存空间首地址(这时候的instance不为null)
                    //但由于指令重排序(Java编译器允许处理器乱序执行)的存在，上面三个步骤可能是1-2-3也可能是
                    //1-3-2，注意，如果是1-3-2的情况就可能出现问题，我们来分析一下可能出现的问题：
                    //I：假设现在两个线程thread1、thread2，现在threa1获取到monitor，然后按照上面的1-3-2执行，
                    //II：假设在3执行完毕、2未执行之前(或者说2只执行一部分，SingletonPattern3中的引用类型
                    //的属性一部分还是null)，这个时候切换到thread2上，
                    //III：这时候instance因为已经在thread1内执行过了(3)，instance已经是非空了，所以
                    //thread2直接拿走instance，然后使用，但是实际上instance指向的内存地址并没有调用构造器
                    //初始化的，这就可能会出现问题了。
                    instance = new SingletonPattern3();
                }
            }
        }
        return SingletonPattern3.instance;
    }
}

//Holder方式：延迟加载、不加锁、线程安全
public class SingletonPattern4 {

    private SingletonPattern4() {
        //do sth about init
    }

    //在静态内部类中，有SingletonPattern4的实例，并且直接被初始化
    private static class Holder {
        private static SingletonPattern4 instance = new SingletonPattern4();
    }

    //返回的是Holer的静态成员instance
    public static SingletonPattern4 getInstance() {
        //在SingletonPattern4中没有instance的静态成员，而是将其放到了静态内部类Holder之中，因此在
        //SingletonPattern4类的初始化中并不会创建Singleton(延迟加载)的实例，Holder中定义了
        //SingletonPattern4的静态变量，并且直接进行了初始化。当Holder被主动引用的时候会创建
        //SingletonPattern4的实例，SingletonPattern4实例的创建过程在Java程序编译时候由同步方法<clinit>()
        //方法执行，保证内存的可见性、JVM指令的顺序性和原子性。
        return Holder.instance;
    }
}
```

