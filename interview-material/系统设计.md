

## 搭建高并发秒杀系统
### 技术特点
* 读多写少
    - 缓存
        - 分布式缓存
        - 本地缓存
        - CDN
        
    
* 高并发
    - 限流（重点）
    - 负载均衡（分布式）
    - 缓存
    - 异步（消息队列削峰） 将请求打入消息队列，然后导入秒杀系统
    
* 资源冲突
    - 库存的控制（操作变为原子操作） 
        - 分布式锁
            - redis
            - zookeeper
        - 数据库锁
            - 乐观锁
            - 悲观锁
        - redis的原子操作类
### 宏观基本架构
* 应用层 -> 浏览器     ->  浏览器缓存、本地缓存、按钮控制、图形验证码
* 网络层 -> 网络路由   ->  CDN （放置静态资源）
* 负载层 -> nginx     ->  负载均衡、动静分离、限流、反向代理缓存
* 服务层 -> java应用   ->  页面静态化、分布式缓存（本地缓存）、异步、队列、限流、原子操作
* 数据库 -> mysql      ->  悲观锁、乐观锁

### 秒杀人群、并发规模的预估
* 主要目的：确定最终的技术选型以及服务器的容量
    - 估算并发峰值：
    
* 如果是 1W 并发

* 限流算法
    - 令牌桶 ：每秒钟产生固定数量的令牌
    - 漏桶 ：流入的流量速率是一定的


1W并发请求进来 
-> nginx(通过配置文件对IP进行限流，漏桶算法限流，也可以配置最大连接数)
-> 分布式限流（redis + lua）
-> 单应用层再次限流（guava rateLimiter 进行限流，令牌桶算法）
-> 数据库（悲观锁、乐观锁）

### 技术选型
* 乐观锁：version机制， 原则上吞吐量更高一些
* 悲观锁： for update 原则上吞吐量低一些
* 在高并发的情况下，冲突非常高的情况下，悲观锁的效率比乐观锁高。
* 两种锁的选择标准
    - 如果要很快的响应速度，建议乐观锁，不带重试的那种
    - 冲突频率高的时候，悲观锁的效率更高一些
    - 重试代价大时，使用悲观锁
* redis原子操作减库存
    - inc(-1) 单线程，保证原子性
    - 与数据库放在同一个事务里，先操作redis，再操作数据库

* 订单系统
    - 注意接口的幂等性
    - 注意扣减库存时防止超卖









    
















