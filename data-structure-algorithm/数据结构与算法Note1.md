

常用的五大算法，包含 动态规划、分治法、贪心求解法、回朔法、分支限界法。

## 时间复杂度

* Cn0+Cn1+Cn2+Cn3+...+Cnn = 2^n




## 字符串
### KMP
* 寻找前缀后缀最长公共元素的长度
* KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。










## 动态规划
三个重要元素：最优子结构、边界、状态转移公式

* 最大子序和 （leetcode 53） 
    - 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。


## 链表
通过链表的两个快、慢指针确定中间节点的位置



## 树
### B+tree

### LSM tree

### Binary Search Tree（二叉搜索树）
二叉排序树，或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点
的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树。



## 类比 
 
* 最长公共子序列 (LCS)
    - 动态规划：
        - dp[i][j] 表示以 A[i] B[j] 为结尾的计算最长公共子序列的长度， dp[lenA-1][lenB-1] 即为最长公共子串的长度
        - if str1Arr[i] == str2Arr[j] ->  dp[i][j] = dp[i - 1][j - 1] + 1
        - else  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    - 输出最长公共子序列：
        - 根据 dp 矩阵，从右下角开始回溯，找到所有的子序列。
* 最长公共子串 
    - 动态规划： 
        - if str1Arr[i] == str2Arr[j] -> dp[i][j] = dp[i - 1][j - 1] + 1  

* 最长递增子序列 (LIS) 
    - 不一定连续，但是顺序不能乱
    - 动态规划：
        - L(j)={ max(L(i))+1, i<j且a[i]<a[j] }。
        - 遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]<a[j]的L(i)，求出max(L(i))+1即为L(j)的值。
        - 遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。
    - 转化为最长公共子序列的方法
        - 将原序列 A 进行排序获得序列 A'，再求两个序列的最长公共子序列
* 最长连续递增子序列
    - 一定要连续
    - 动态规划：
        - 初始化 dp[len] = 1， if (nums[i] > nums[i - 1]) ->  dp[i] = dp[i - 1] + 1;

* 最长回文子序列
    - 动态规划： 针对某一个子串 s[i,j]
        - if s.charAt(i) == s.charAt(j) -> dp[i][j] = dp[i+1][j-1] + 2
        - else -> dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
* 最长回文子串
    - 以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。
    - Manacher 算法








